##################################################
# Structure variation calling using genome assambly and long reads
# Merge SVs from different tools using PanPop pipeline
# Author: Zeyu Zheng
# Time: 2023-2-8
# Email: asd63zhengzeyu@126.com
##################################################

import os
import pandas as pd
import shutil

configfile: "configs/software.yaml"
configfile: "configs/base.yaml"
configfile: "configs/config.pop3.yaml"


#SAMPLE_INDEX = {"Alo-0", "Cas-0", "Cat-0", "Col-0", "Cvi-0", "Hom-4", "Hum-2", "Ler-0", "Ped-0"}
SAMPLE_LIST = config['sample_reads_list_file']
INDEX_REF = "Ref.fa"

SLURM_PART = 'pNormal'

MIN_SUPPORT_CALLER = 2 # Min support SV Caller count, Default 2

# paths
NGMLR = shutil.which(config['ngmlr'])
SNIFFLES = shutil.which(config['sniffles'])
CUTESV = shutil.which(config['cutesv'])
SVIM = shutil.which(config['svim'])
PICARD = shutil.which(config['picard'])
#SURVIVOR = shutil.which(config['survivor'])
PBSV = shutil.which(config['pbsv'])
NUCMER = shutil.which(config['nucmer'])
DELTAFILTER = shutil.which(config['deltafilter'])
SHOWCOORDS = shutil.which(config['showcoords'])
ASSEMBLYTICS = shutil.which(config['assemblytics'])
BEDTOOLS = shutil.which(config['bedtools'])
BCFTOOLS = shutil.which(config['bcftools'])
TABIX = shutil.which(config['tabix'])

ZWORKDIR = config['workdir']
workdir: ZWORKDIR


S2T = pd.read_csv(SAMPLE_LIST, sep='\t', index_col='sample')
SAMPLE_INDEX = S2T.index

include: "subworkflows/callSV3.py"


rule all:
    input:
        expand("04_consensus_vcf/{sample}/10.concat_inv.split.sv.vcf.gz",sample=SAMPLE_INDEX),
        expand("04_consensus_vcf/{sample}/00.inv.vcf.gz", sample=SAMPLE_INDEX)




rule merge_vcf_same_pos:
    input:
        vcf = "04_consensus_vcf/{sample}/01.merged.vcf.gz",
        ref = INDEX_REF
    output:
        vcf = "04_consensus_vcf/{sample}/02.merge_vcf_same_pos.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/02.merge_vcf_same_pos.sort.vcf.gz",
    threads: 64
    log: "logs/3.02.{sample}.merge_vcf_same_pos.log"
    resources:
        mem_mb = 8000
    shell:
        """
        perl {workflow.basedir}/scripts/merge_vcf_same_pos.pl --invcf {input.vcf} --outvcf {output.vcf} --ref {input.ref} --skip_mut_at_same_pos 2 --threads 30 --ignore_dp >>{log} 2>&1 && \
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1
        """


rule gen_merge_mask:
    input:
        vcf = "04_consensus_vcf/{sample}/02.merge_vcf_same_pos.sort.vcf.gz",
    output:
        bed = "04_consensus_vcf/{sample}/02.merge_vcf_same_pos.sort.vcf.gz.mask.bed",
    log: "logs/3.02.{sample}.gen_merge_mask.log"
    resources:
        mem_mb = 8000
    shell:
        """
        perl {workflow.basedir}/scripts/realign_gen_mask.pl -i {input.vcf} -o {output.bed} >>{log} 2>&1
        """

rule realign1:
    input:
        vcf = "04_consensus_vcf/{sample}/02.merge_vcf_same_pos.sort.vcf.gz",
        ref = INDEX_REF
    output:
        vcf = "04_consensus_vcf/{sample}/03.realign1.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/03.realign1.sort.vcf.gz",
    threads: 64
    log: "logs/3.03.{sample}.realign1.log"
    resources:
        mem_mb = 40000
    shell:
        """
        thread_num=`echo {threads} | perl -ne 'chomp;$a=int($_/4); print $a>1?$a:1'`
        perl {workflow.basedir}/scripts/realign.pl --chr_tolerance --in_vcf {input.vcf} --out_vcf {output.vcf} --ref_fasta_file {input.ref} --threads $thread_num --level 1 --skip_mut_at_same_pos 2 --ext_bp_min 100 --ext_bp_max 400 --first_merge >>{log} 2>&1 && \
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1
        """

rule realign12:
    input:
        vcf = "04_consensus_vcf/{sample}/03.realign1.sort.vcf.gz",
        ref = INDEX_REF
    output:
        vcf = "04_consensus_vcf/{sample}/03.realign2.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/03.realign2.sort.vcf.gz",
    threads: 64
    log: "logs/3.03.{sample}.realign12.log"
    resources:
        mem_mb = 40000
    shell:
        """
        #thread_num=`echo {threads} | awk '{{print $1/4}}'`
        thread_num=`echo {threads} | perl -ne 'chomp;$a=int($_/4); print $a>1?$a:1'`
        perl {workflow.basedir}/scripts/realign.pl --chr_tolerance --in_vcf {input.vcf} --out_vcf {output.vcf} --ref_fasta_file {input.ref} --threads $thread_num --level 6 --skip_mut_at_same_pos 2 >>{log} 2>&1
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1
        """


rule thin11:
    input:
        vcf = "04_consensus_vcf/{sample}/03.realign2.sort.vcf.gz",
    output:
        vcf = "04_consensus_vcf/{sample}/04.thin1.vcf.gz"
    threads: 64
    resources:
        mem_mb = 10000
    log: "logs/3.04.{sample}.thin11.log"
    shell:
        """
        #thread_num=`echo {threads} | awk '{{print $1/2}}'`
        thread_num=`echo {threads} | perl -ne 'chomp;$a=int($_/2); print $a>1?$a:1'`
        perl {workflow.basedir}/scripts/merge_similar_allele.pl  --invcf {input.vcf} --outvcf {output.vcf} --sv2pav_merge_diff_threshold 40 --sv2pav_merge_identity_threshold 0.6 --threads $thread_num >>{log} 2>&1
        """

# perl {workflow.basedir}/scripts/sv2pav.pl --invcf 7.thin1.vcf.gz --outvcf 7.thin2.vcf.gz --max_len_tomerge 5 --sv_min_dp 50
rule thin12:
    input:
        vcf = "04_consensus_vcf/{sample}/04.thin1.vcf.gz",
    output:
        vcf = "04_consensus_vcf/{sample}/04.thin2.vcf.gz"
    threads: 64
    log: "logs/3.04.{sample}.thin12.log"
    resources:
        mem_mb = 4000
    shell:
        """
        perl {workflow.basedir}/scripts/sv2pav.pl --invcf {input.vcf} --outvcf {output.vcf} --enable_norm_alle 1 --max_len_tomerge 20 --sv_min_dp 40 --threads {threads} >>{log} 2>&1
        """

rule realign2:
    input:
        vcf = "04_consensus_vcf/{sample}/04.thin2.vcf.gz",
        ref = INDEX_REF
    output:
        vcf = "04_consensus_vcf/{sample}/05.realign2.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/05.realign2.sort.vcf.gz",
    threads: 64
    log: "logs/3.05.{sample}.realign2.log"
    resources:
        mem_mb = 20000
    shell:
        """
        #thread_num=`echo {threads} | awk '{{print $1/4}}'`
        thread_num=`echo {threads} | perl -ne 'chomp;$a=int($_/4); print $a>1?$a:1'`
        perl {workflow.basedir}/scripts/realign.pl --chr_tolerance --in_vcf {input.vcf} --out_vcf {output.vcf} --ref_fasta_file {input.ref} --threads $thread_num --level 1 --skip_mut_at_same_pos 2 --ext_bp_min 100 --ext_bp_max 400 >>{log} 2>&1 && \
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1
        """

rule thin21:
    input:
        vcf = "04_consensus_vcf/{sample}/05.realign2.sort.vcf.gz",
    output:
        vcf = "04_consensus_vcf/{sample}/06.thin1.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/06.thin1.sort.vcf.gz"
    threads: 64
    log: "logs/3.06.{sample}.thin21.log"
    resources:
        mem_mb = 10000
    shell:
        """
        #thread_num=`echo {threads} | awk '{{print $1/2}}'`
        thread_num=`echo {threads} | perl -ne 'chomp;$a=int($_/2); print $a>1?$a:1'`
        perl {workflow.basedir}/scripts/merge_similar_allele.pl --invcf {input.vcf} --outvcf {output.vcf} --sv2pav_merge_diff_threshold 40 --sv2pav_merge_identity_threshold 0.5 --threads $thread_num >>{log} 2>&1 && \
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1
        """
    
rule thin22:
    input:
        vcf = "04_consensus_vcf/{sample}/06.thin1.sort.vcf.gz",
    output:
        vcf = "04_consensus_vcf/{sample}/06.thin2.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/06.thin2.sort.vcf.gz"
    threads: 64
    log: "logs/3.06.{sample}.thin22.log"
    resources:
        mem_mb = 4000
    shell:
        """
        perl {workflow.basedir}/scripts/sv2pav.pl --invcf {input.vcf} --outvcf {output.vcf} --enable_norm_alle 1 --max_len_tomerge 20 --sv_min_dp 40 --threads {threads} >>{log} 2>&1 && \
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1
        """

rule merge_callers:
    input:
        vcf = "04_consensus_vcf/{sample}/06.thin2.sort.vcf.gz",
    output:
        vcf = "04_consensus_vcf/{sample}/07.merge_callers.vcf.gz"
    threads: 1
    log: "logs/3.07.{sample}.merge_callers.log"
    resources:
        mem_mb = 4000
    params:
        ext_parm = " --force_merge_insertion ",
        min_support_callers = MIN_SUPPORT_CALLER
    shell:
        """
        perl {workflow.basedir}/scripts/long_caller_merger.pl --in {input.vcf} --min_supporting {params.min_support_callers} -s {wildcards.sample} --out {output.vcf} {params.ext_parm} >>{log} 2>&1
        """

rule realign3:
    input:
        vcf = "04_consensus_vcf/{sample}/07.merge_callers.vcf.gz",
        ref = INDEX_REF,
        mask_bed = "04_consensus_vcf/{sample}/02.merge_vcf_same_pos.sort.vcf.gz.mask.bed"
    output:
        vcf = "04_consensus_vcf/{sample}/08.realign_merge.vcf.gz"
    threads: 64
    log: "logs/3.08.{sample}.realign3.log"
    resources:
        mem_mb = 4000
    shell:
        """
        #thread_num=`echo {threads} | awk '{{print $1/4}}'`
        thread_num=`echo {threads} | perl -ne 'chomp;$a=int($_/4); print $a>1?$a:1'`
        perl {workflow.basedir}/scripts/realign.pl --chr_tolerance --in_vcf {input.vcf} --out_vcf {output.vcf} --ref_fasta_file {input.ref} --threads $thread_num --level 1 --skip_mut_at_same_pos 2 --ext_bp_min 1000 --ext_bp_max 1000 --mask_bed_file {input.mask_bed} --skip_snp 1 >>{log} 2>&1
        """

rule thin32:
    input:
        vcf = "04_consensus_vcf/{sample}/08.realign_merge.vcf.gz",
    output:
        vcf = "04_consensus_vcf/{sample}/09.thin2.vcf.gz",
        vcfsorted = "04_consensus_vcf/{sample}/09.thin2.sort.vcf.gz",
        vcfsorted_tbi = "04_consensus_vcf/{sample}/09.thin2.sort.vcf.gz.tbi"
    threads: 64
    log: "logs/3.06.{sample}.thin22.log"
    resources:
        mem_mb = 4000
    shell:
        """
        perl {workflow.basedir}/scripts/sv2pav.pl --invcf {input.vcf} --outvcf {output.vcf} --enable_norm_alle 1 --sv_min_dp 40 --threads {threads} --max_len_tomerge 0 >>{log} 2>&1 && \
        {BCFTOOLS} sort -O z -o {output.vcfsorted} {output.vcf} >>{log} 2>&1 && \
        {TABIX} {output.vcfsorted} >>{log} 2>&1
        """


rule concat_inv:
    input:
        vcf1 = "04_consensus_vcf/{sample}/09.thin2.sort.vcf.gz",
        vcf2 = "04_consensus_vcf/{sample}/00.inv.vcf.gz",
    log: "logs/3.10.{sample}.concat_inv.log"
    output:
        vcf = "04_consensus_vcf/{sample}/10.concat_inv.vcf.gz", 
    shell:
        """
        {BCFTOOLS} concat -a {input.vcf1} {input.vcf2} 2>>{log} | {BCFTOOLS} sort | bgzip -c > {output.vcf} && \
        {TABIX} {output.vcf} >>{log} 2>&1
        """

rule split_snp_indel_sv:
    input:
        vcf = "04_consensus_vcf/{sample}/10.concat_inv.vcf.gz"
    output:
        sv = "04_consensus_vcf/{sample}/10.concat_inv.split.sv.vcf.gz",
        indel = "04_consensus_vcf/{sample}/10.concat_inv.split.indel.vcf.gz",
        snp = "04_consensus_vcf/{sample}/10.concat_inv.split.snp.vcf.gz"
    log: "logs/3.10.{sample}.split_snp_indel_sv.log"
    threads: 1
    resources:
        mem_mb = 4000
    params:
        prefix = "04_consensus_vcf/{sample}/10.concat_inv.split"
    shell:
        """
        perl {workflow.basedir}/scripts/vcf_split_snp_indel_sv.pl {input.vcf} {params.prefix} 50 >>{log} 2>&1
        """
